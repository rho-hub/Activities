{"ast":null,"code":"export const getCurrentLocation = () => {\n  return new Promise((resolve, reject) => {\n    if (!navigator.geolocation) {\n      // Fallback to IP-based location with error handling\n      fetch('https://ipapi.co/json/').then(res => res.json()).then(data => {\n        if (data.latitude && data.longitude) {\n          resolve({\n            lat: parseFloat(data.latitude),\n            lng: parseFloat(data.longitude),\n            accuracy: 50000,\n            // Approximate accuracy for IP-based location\n            source: 'ip'\n          });\n        } else {\n          reject(new Error(\"Couldn't determine location\"));\n        }\n      }).catch(() => reject(new Error(\"Location services unavailable\")));\n      return;\n    }\n    const options = {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 0\n    };\n    navigator.geolocation.getCurrentPosition(position => resolve({\n      lat: position.coords.latitude,\n      lng: position.coords.longitude,\n      accuracy: position.coords.accuracy,\n      source: 'gps'\n    }), error => {\n      console.warn(`Geolocation error (${error.code}): ${error.message}`);\n      // Fallback to IP-based location\n      fetch('https://ipapi.co/json/').then(res => res.json()).then(data => {\n        if (data.latitude && data.longitude) {\n          resolve({\n            lat: parseFloat(data.latitude),\n            lng: parseFloat(data.longitude),\n            accuracy: 50000,\n            source: 'ip'\n          });\n        } else {\n          reject(error);\n        }\n      }).catch(() => reject(error));\n    }, options);\n  });\n};\nexport const fetchNearbyPlaces = (map, location) => {\n  return new Promise((resolve, reject) => {\n    if (!map || !window.google) return reject(\"Map not loaded\");\n    const service = new window.google.maps.places.PlacesService(map);\n    const request = {\n      location: new window.google.maps.LatLng(location.lat, location.lng),\n      radius: 5000,\n      type: ['park', 'tourist_attraction', 'amusement_park']\n    };\n    service.nearbySearch(request, (results, status) => {\n      if (status === window.google.maps.places.PlacesServiceStatus.OK) {\n        resolve(results);\n      } else {\n        reject(status);\n      }\n    });\n  });\n};","map":{"version":3,"names":["getCurrentLocation","Promise","resolve","reject","navigator","geolocation","fetch","then","res","json","data","latitude","longitude","lat","parseFloat","lng","accuracy","source","Error","catch","options","enableHighAccuracy","timeout","maximumAge","getCurrentPosition","position","coords","error","console","warn","code","message","fetchNearbyPlaces","map","location","window","google","service","maps","places","PlacesService","request","LatLng","radius","type","nearbySearch","results","status","PlacesServiceStatus","OK"],"sources":["C:/Users/USER/Desktop/events-explorer/src/services/mapsService.js"],"sourcesContent":["export const getCurrentLocation = () => {\r\n  return new Promise((resolve, reject) => {\r\n    if (!navigator.geolocation) {\r\n      // Fallback to IP-based location with error handling\r\n      fetch('https://ipapi.co/json/')\r\n        .then(res => res.json())\r\n        .then(data => {\r\n          if (data.latitude && data.longitude) {\r\n            resolve({\r\n              lat: parseFloat(data.latitude),\r\n              lng: parseFloat(data.longitude),\r\n              accuracy: 50000, // Approximate accuracy for IP-based location\r\n              source: 'ip'\r\n            });\r\n          } else {\r\n            reject(new Error(\"Couldn't determine location\"));\r\n          }\r\n        })\r\n        .catch(() => reject(new Error(\"Location services unavailable\")));\r\n      return;\r\n    }\r\n\r\n    const options = {\r\n      enableHighAccuracy: true,\r\n      timeout: 10000,\r\n      maximumAge: 0\r\n    };\r\n\r\n    navigator.geolocation.getCurrentPosition(\r\n      (position) => resolve({\r\n        lat: position.coords.latitude,\r\n        lng: position.coords.longitude,\r\n        accuracy: position.coords.accuracy,\r\n        source: 'gps'\r\n      }),\r\n      (error) => {\r\n        console.warn(`Geolocation error (${error.code}): ${error.message}`);\r\n        // Fallback to IP-based location\r\n        fetch('https://ipapi.co/json/')\r\n          .then(res => res.json())\r\n          .then(data => {\r\n            if (data.latitude && data.longitude) {\r\n              resolve({\r\n                lat: parseFloat(data.latitude),\r\n                lng: parseFloat(data.longitude),\r\n                accuracy: 50000,\r\n                source: 'ip'\r\n              });\r\n            } else {\r\n              reject(error);\r\n            }\r\n          })\r\n          .catch(() => reject(error));\r\n      },\r\n      options\r\n    );\r\n  });\r\n};\r\n\r\nexport const fetchNearbyPlaces = (map, location) => {\r\n  return new Promise((resolve, reject) => {\r\n    if (!map || !window.google) return reject(\"Map not loaded\");\r\n    \r\n    const service = new window.google.maps.places.PlacesService(map);\r\n    const request = {\r\n      location: new window.google.maps.LatLng(location.lat, location.lng),\r\n      radius: 5000,\r\n      type: ['park', 'tourist_attraction', 'amusement_park']\r\n    };\r\n\r\n    service.nearbySearch(request, (results, status) => {\r\n      if (status === window.google.maps.places.PlacesServiceStatus.OK) {\r\n        resolve(results);\r\n      } else {\r\n        reject(status);\r\n      }\r\n    });\r\n  });\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}